<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="MEINESON,meineson@gmail.com"><title>FFMPEG 8.0 WHIP推流bug分析 · MBSTUDIO</title><meta name="description" content="继解决了Android Mediacodec编码H264码流下降的问题后，码流上来了，WHIP推流也一如既往的奔溃了，毕竟是刚发布几个月的“试验性”功能……

话说FFMPEG为了抢市场，这个试验功能推出的也够仓促的，好多参数全部写死，视频只支持H264，音频只支持OPUS并且强制2声道48000H"><meta name="keywords" content="mbstudio,ICT,RCS,Deep Learning,Digital Twin,AIGC"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">MBSTUDIO</a></h3><div class="description"><p>魔瓶工作室 since 2001 /RCS OS IOT AI DT/</p></div></div></div><ul class="social-links"><li><a href="mailto:meineson@gmail.com"><i class="fa fa-envelope">         </i></a></li><li><a target="_blank" rel="noopener" href="https://weibo.com/meineson"><i class="fa fa-weibo"></i></a></li><li><a target="_blank" rel="noopener" href="http://github.com/meineson"><i class="fa fa-github"></i></a></li></ul><div class="footer"></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/me.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>FFMPEG 8.0 WHIP推流bug分析</a></h3></div><div class="post-content"><blockquote>
<p>继解决了Android Mediacodec编码H264码流下降的问题后，码流上来了，WHIP推流也一如既往的奔溃了，毕竟是刚发布几个月的“试验性”功能……</p>
</blockquote>
<p>话说FFMPEG为了抢市场，这个试验功能推出的也够仓促的，好多参数全部写死，视频只支持H264，音频只支持OPUS并且强制2声道48000Hz采样，啥VP8，VP9，711编码都不带给你的，而且随8.0主版本发布的还有ICE协商BUG导致许多流媒体服务器在ICE协商这步就出错，然后连接超时，根本推不了流，许多人可能尝试到这步这放弃了。</p>
<p>经过抓包才发现，STUN消息里少了关键字段服务器不认。然后想自己手写补丁的，上Git仓库一看，8.1 dev中有更新修正了，打上补丁在桌面系统上可以正常使用mp4文件进行推流了，以为一切ok就在Android上尝试一下吧，一试就出现了上面的编码码流问题，然后就是反复的错误，反复的ret返回-11错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E  Failed to write packet=1194B, ret=-11</span><br><span class="line">E  Failed to write packet, size=37952 Try again</span><br></pre></td></tr></table></figure>

<p>可以看到，mediacodec上了高码率后，产出的nal包特别大，远超MTU大小，rtp肯定需要分片才能正常发送（rtp muxer负责在ff_rtp_send_h264_hevc中，进行nal分片，最后是nal_send发送的，所以并不是网上说的ffmpeg不直接提供H264裸包的nal分片功能，而是它不对外提供接口，只是自己内部使用）。</p>
<p>实际测试，同样10000+和20000+的包有时能发送，有时发送错误，再根据错误码-11是EAGIN，即重试，一般都是因为网络堵塞或服务器性能太差容量造成，但这个错误一般是发生在刚开始推送的前几秒，也不太象。</p>
<p>对比了桌面环境下的使用mp4文件的推流并调高码率，或Android下直接推流rtp_mpegts都没有这个问题，网络资源和AI都说不出个所以然，只能继续源码分析了。</p>
<p>来分析一下whip.c的源码吧，跟随错误到达这里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ret = ff_write_chained(rtp_ctx, 0, pkt, s, 0);</span><br><span class="line">    if (ret &lt; 0) &#123;</span><br><span class="line">        if (ret == AVERROR(EINVAL)) &#123;</span><br><span class="line">            av_log(whip, AV_LOG_WARNING, &quot;Ignore failed to write packet=%dB, ret=%d\n&quot;, pkt-&gt;size, ret);</span><br><span class="line">            ret = 0;</span><br><span class="line">        &#125; else</span><br><span class="line">            av_log(whip, AV_LOG_ERROR, &quot;Failed to write packet, size=%d %s\n&quot;, pkt-&gt;size, av_err2str(ret));</span><br><span class="line">        goto end;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这代码可以说相当简陋了，就是利用了ffmpeg的链式写入功能，whip是实现成一个MUXER，在主程序逻辑中，将编码好的H264，OPUS AVPacket包通过av_interleaved_write_frame(ofmt_ctx, aPacket)喂给whip时，它反手就是调用ff_write_chained将packet扔给了rtp_ctx（往上翻代码可以看到是通过create_rtp_muxer创建的一个rtp muxer）。</p>
<p>创建rtp muxer过程中，还贴心的给了一个:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buffer_size = MAX_UDP_BUFFER_SIZE;</span><br><span class="line">rtp_ctx-&gt;pb = avio_alloc_context(buffer, buffer_size, 1, s, NULL, on_rtp_write_packet, NULL);</span><br></pre></td></tr></table></figure>
<p>将写给whip的原始packet，最后不是直接使用的rtp muxer的rtp_write_packet,而是先给on_rtp_write_packet进行srtp加密再发送，上面的错误也正是这里产生：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* Encrypt by SRTP and send out. */</span><br><span class="line">cipher_size = ff_srtp_encrypt(srtp, buf, buf_size, whip-&gt;buf, sizeof(whip-&gt;buf));</span><br><span class="line">if (cipher_size &lt;= 0 || cipher_size &lt; buf_size) &#123;</span><br><span class="line">    av_log(whip, AV_LOG_WARNING, &quot;Failed to encrypt packet=%dB, cipher=%dB\n&quot;, buf_size, cipher_size);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rtp_write_packetret = ffurl_write(whip-&gt;udp, whip-&gt;buf, cipher_size);</span><br><span class="line">if (ret &lt; 0) &#123;</span><br><span class="line">    av_log(whip, AV_LOG_ERROR, &quot;Failed to write packet=%dB, ret=%d\n&quot;, cipher_size, ret);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以回到上面的mp4文件和rtp_mpegts为什么正常呢？</p>
<blockquote>
<p>mp4文件中包含的mp4数据不像硬件编码器是实时吐出的数据，文件不会突然产生例如37952这么大的nal包，而是规则大小的，有兴趣的可以在解码前打印frame的大小。</p>
</blockquote>
<blockquote>
<p>而rtp_mpegts是使用的rtp_mpegts muxer，再链式调用rtp muxer（行为类似whip），但它写数据时，是rtp_mpegts_write_packet直接调用av_write_frame(chain-&gt;rtp_ctx, local_pkt)，这里与whip处理逻辑不同，不能简单对比了。</p>
</blockquote>
<p>问题再次聚焦到上面的ffurl_write上，代码中有一条TODO：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* TODO: Use AVIOContext instead of URLContext */</span><br><span class="line">URLContext *dtls_uc;</span><br><span class="line">/* The UDP transport is used for delivering ICE, DTLS and SRTP packets. */</span><br><span class="line">URLContext *udp;</span><br></pre></td></tr></table></figure>
<p>作者暗示了这么写的确可能有些问题，进一步分析下代码，看udp是啥时候分配初始化的。</p>
<p>ice_dtls_handshake是webrtc逻辑中，ice协商完毕，建立dtls即媒体srtp通信时调用的，这时候应该就是rtp相关的udp初始化位置，定位到whip-&gt;state &#x3D; WHIP_STATE_ICE_CONNECTED;即ice成功协商到可用的媒体地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ff_url_join(buf, sizeof(buf), &quot;dtls&quot;, NULL, whip-&gt;ice_host, whip-&gt;ice_port, NULL);</span><br><span class="line">ret = ffurl_open_whitelist(&amp;whip-&gt;dtls_uc, buf, AVIO_FLAG_READ_WRITE, &amp;s-&gt;interrupt_callback,</span><br><span class="line">                    &amp;opts, s-&gt;protocol_whitelist, s-&gt;protocol_blacklist, NULL);</span><br></pre></td></tr></table></figure>
<p>注意这里ffurl_open_whitelist又是ffmpeg特色的链式调用，它会层层调用下一层的协议，通过ff_url_join就知道它构建了新的下级url格式并进行调用，例如这里，dtls是在tls.c中定义，并且根据协议类型，调用了下级udp协议。</p>
<p>通过跟踪一个典型的巨大包的发送和报错逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">0: write len=112624</span><br><span class="line">2025-09-25 11:27:03.174 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  Sending NAL 1 of len 112620 M=1</span><br><span class="line">2025-09-25 11:27:03.174 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  NAL size 112620 &gt; 1172</span><br><span class="line">2025-09-25 11:27:03.174 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.174 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.174 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.174 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.175 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.175 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.175 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.175 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.175 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.175 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.175 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.175 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.176 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.176 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.176 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.176 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.176 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.176 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.176 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.176 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.177 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.177 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.177 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.177 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.177 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.177 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.177 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.177 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.178 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.178 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.178 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.178 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.178 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.178 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.178 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.178 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.179 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.179 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.179 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   D  rtp_send_data size=1172</span><br><span class="line">2025-09-25 11:27:03.179 16269-16407 ffmpeg lib              cn.mbstudio.mewhip                   E  Failed to write packet=1194B, ret=-11</span><br></pre></td></tr></table></figure>

<p>可知它经过了rtp协议处理（主要是h264 nal分片和打包成rtp），再经过srtp封包成dtls，再由openssl通过udp协议最终发送出去。</p>
<p>rtp_send_data size&#x3D;</p>
<p>没有任何错误，表示rtp过程正常，问题还是出在最后的openssl发送关节上，即udp协议。</p>
<p>核心代码是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (!(h-&gt;flags &amp; AVIO_FLAG_NONBLOCK)) &#123;</span><br><span class="line">    ret = ff_network_wait_fd(s-&gt;udp_fd, 1);</span><br><span class="line">    if (ret &lt; 0)</span><br><span class="line">        return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!s-&gt;is_connected) &#123;</span><br><span class="line">    ret = sendto (s-&gt;udp_fd, buf, size, 0,</span><br><span class="line">                  (struct sockaddr *) &amp;s-&gt;dest_addr,</span><br><span class="line">                  s-&gt;dest_addr_len);</span><br><span class="line">&#125; else</span><br><span class="line">    ret = send(s-&gt;udp_fd, buf, size, 0);</span><br></pre></td></tr></table></figure>

<p>因为whip有一次git更新，就是加的AVIO_FLAG_NONBLOCK，所以先看这里。<br>进入函数，果然看到了EAGIN错误的来源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define UDP_TX_BUF_SIZE 32768</span><br><span class="line"></span><br><span class="line">int ff_network_wait_fd(int fd, int write)</span><br><span class="line"> &#123;</span><br><span class="line">     int ev = write ? POLLOUT : POLLIN;</span><br><span class="line">     struct pollfd p = &#123; .fd = fd, .events = ev, .revents = 0 &#125;;</span><br><span class="line">     int ret;</span><br><span class="line">     ret = poll(&amp;p, 1, POLLING_TIME);</span><br><span class="line">     return ret &lt; 0 ? ff_neterrno() : p.revents &amp; (ev | POLLERR | POLLHUP) ? 0 : AVERROR(EAGAIN);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>注意看UDP_TX_BUF_SIZE值，当mediacodec的单个包大小超过它时，它一下子堵塞了udp发送缓冲区，而现在的whip实现，也并没有对EAGIN进行任何处理，导致继续向里面不停扔数据，最终导致整个程序垮掉。</p>
<p>而这个值本来是可以通过av_dict_set进来的，udp.c中也会读取这个值，如果这个值没有才会使用上面的默认值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (s-&gt;buffer_size &lt; 0)</span><br><span class="line">    s-&gt;buffer_size = is_output ? UDP_TX_BUF_SIZE : UDP_RX_BUF_SIZE;</span><br><span class="line"></span><br><span class="line">//...</span><br><span class="line"></span><br><span class="line">if (av_find_info_tag(buf, sizeof(buf), &quot;buffer_size&quot;, p)) &#123;</span><br><span class="line">    s-&gt;buffer_size = strtol(buf, NULL, 10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理论上，传递参数给最上层的MUXER并层层传递到最底层的udp即可，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">av_dict_set(&amp;format_opts, &quot;buffer_size&quot;,  &quot;8M&quot;, 0); //rtp buffer size</span><br><span class="line"></span><br><span class="line">参数从：WHIP MUXER -&gt; RTP -&gt; SRTP -&gt; DTLS -&gt; UDP依次传递。</span><br></pre></td></tr></table></figure>

<p>但现实是, WHIP.c在打开dtls的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffurl_open_whitelist(&amp;whip-&gt;dtls_uc, buf, AVIO_FLAG_READ_WRITE, &amp;s-&gt;interrupt_callback,</span><br><span class="line">                    &amp;opts, s-&gt;protocol_whitelist, s-&gt;protocol_blacklist, NULL);</span><br></pre></td></tr></table></figure>
<p>就没有提供任何接口或方法来传递这个值，难怪网上之前看到过一个留言，信誓旦旦地说，FFMPEG只适合干2M以下的流媒体工作，一旦超过2M就各种不稳定的异常，想来也是这方面的原因吧。</p>
<p>知道的原理和原因，解决办法就看你自己了，要么手工硬编码，把上面那个UDP_TX_BUF_SIZE值改大，要么按上面说的原理，把av_dict_set的buffer_size值一层层传递进去吧，祝好运。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2025-09-25</span><i class="fa fa-tag"></i><a class="tag" href="/tags/技术分析/" title="技术分析">技术分析 </a><a class="tag" href="/tags/程序开发/" title="程序开发">程序开发 </a><a class="tag" href="/tags/流媒体技术/" title="流媒体技术">流媒体技术 </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://mbstudio.cn/ffmpeg_whip/,MBSTUDIO,FFMPEG 8.0 WHIP推流bug分析,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/chromium_vaapi/" title="Electron及Chromium/Chrome在Linux平台VAAPI硬件编解码兼容性">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/ffmpeg_mediacodec/" title="FFMPEG硬件编码（MediaCodec）异常降低码率BUG">下一篇</a></li></ul></div><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="/js/av-min.js"></script><script src="/js/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:true|| false, 
  app_id:'NJ38qTX1M6HwqDECSFibkJnD-gzGzoHsz',
  app_key:'xsgCybaxfNqU9qWtVSa1CsPU',
  placeholder:'谢绝广告。',
  path: window.location.pathname,
  avatar:''
})

</script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/baidu.js"> </script></body></html>