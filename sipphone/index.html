<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="MEINESON,meineson@gmail.com"><title>oSIP协议栈(及eXoSIP,Ortp等)使用入门 · MBSTUDIO</title><meta name="description" content="一直没空仔细研究下oSIP，最近看到其版本已经到了3.x版本，看到网上的许多帮助说明手册都过于陈旧，且很多文档内容有点误人子弟的嫌疑～～　　Ｌｉｎｕｘ下ｏＳＩＰ的编译使用应该是很简单的，其Ｉｎｓｔａｌｌ说明文档里也介绍的比较清楚，本文主要就ｏＳＩＰ在Ｗｉｎｄｏｗｓ平台下ＶＣ６．０开发环境下的使用作出"><meta name="keywords" content="mbstudio,ICT,RCS,Deep Learning,Digital Twin,AIGC"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">MBSTUDIO</a></h3><div class="description"><p>魔瓶工作室 since 2001 /RCS OS IOT AI DigitalTwin/</p></div></div></div><ul class="social-links"><li><a href="mailto:meineson@gmail.com"><i class="fa fa-envelope">         </i></a></li><li><a target="_blank" rel="noopener" href="https://weibo.com/meineson"><i class="fa fa-weibo"></i></a></li><li><a target="_blank" rel="noopener" href="http://github.com/meineson"><i class="fa fa-github"></i></a></li></ul><div class="footer"></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/me.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>oSIP协议栈(及eXoSIP,Ortp等)使用入门</a></h3></div><div class="post-content"><blockquote>
<p>一直没空仔细研究下oSIP，最近看到其版本已经到了3.x版本，看到网上的许多帮助说明手册都过于陈旧，且很多文档内容有点误人子弟的嫌疑～～<br>　　Ｌｉｎｕｘ下ｏＳＩＰ的编译使用应该是很简单的，其Ｉｎｓｔａｌｌ说明文档里也介绍的比较清楚，本文主要就ｏＳＩＰ在Ｗｉｎｄｏｗｓ平台下ＶＣ６．０开发环境下的使用作出描述。<br>　　虽然ｏＳＩＰ的开发人员也说明了，ｏＳＩＰ只使用了标准Ｃ开发库，但许多人在Ｗｉｎｄｏｗｓ下使用ｏＳＩＰ时，第一步就被卡住了，得不到ｏＳＩＰ的ＬＩＢ库和ＤＬＬ库，也就没有办法将ｏＳＩＰ使用到自己的程序中去，所以第一步，我们将学习如何得到ｏＳＩＰ的静态和动态链接库，以便我们自己的程序能够使用它们来成功编译和执行我们的程序。</p>
</blockquote>
<ul>
<li>第一阶段：<br>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－<br>　　先创建新工程，网上许多文档都介绍创建一个Ｗｉｎ３２动态链接库工程，我们这里也一样，创建一个空白的工程保存。<br>　　同样，将ｏＳＩＰ２版本３．０．１ src目录下的Ｏｓｉｐｐａｒｓｅｒ２目录下的所有文件都拷到我们刚创建的工程的根目录下，在ＶＣ６上操作：<br>Ｐｒｏｊｅｃｔ－Ａｄｄ　Ｔｏ　Ｐｒｏｊｅｃｔ－Ｆｉｌｅｓ</li>
</ul>
<p>　　将所有的源程序和头文件都加入到工程内，保存工程。<br>　　这时，我们可以尝试编译一下工程，你会得到许多错误提示信息，其内容无非是找不到osipparser2&#x2F;xxxxx.h头文件之类。<br>　　处理：在Ｌｉｎｕｘ下，我们一般是将头文件，ｌｉｂ库都拷到&#x2F;usr&#x2F;inclue;&#x2F;usr&#x2F;lib之类的目录下，ｃ源程序里直接写#include &lt;xxx.h&gt;时，能直接去找到它们，在ＶＣ里，同样的，最简单的方法就是将ｏＳＩＰ２源码包中的Ｉｎｃｌｕｄｅ目录下的osipparser2目录直接拷到我们的Ｗｉｎｄｏｗｓ下默认包含目录即可，这个目录在ＶＣ６的Ｔｏｏｌ－Ｏｐｔｉｏｎｓ－Ｄｉｒｅｃｔｏｒｉｅｓ里设置，（当然，如果你知道这一步，也可以不用拷贝文件，直接在这里把ｏＳＩＰ源码包所在目录加进来就可以了），默认如果装在Ｃ盘，目录则为C:\Program Files\Microsoft Visual Studio\VC98\Include。<br>　　这时，我们再次编译我们的工程，顺利编译，生成osipparser2.dll，这时，网上很多文档里可能直接就说，这一步也会生成libs目录，里面里osipparser2.lib文件，但我们这里没有生成：）<br>　　最简单的方法，不用深究，直接再创建一个工程，同上述创建动态链接库方法，创建一个Ｗｉｎ３２静态链接库工程，直接编译，即可得到osipparser2.lib。<br>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－<br>　　上面，我们得到了Ｏｓｉｐ的解析器开发库，下面再编译完整的Ｏｓｉｐ协议栈开发库，同样照上述方法，分别创建动态链接库工程和静态链接库工程，只是要拷的文件换成src下的osip目录下文件和include下的osip目录，得到osip2.dll和osip2.lib。<br>　　在编译osip2.dll这一步可能会再次得到错误，内容含义是找不到链接库，所以，我们要把前面编译得到的osipparser2.lib也拷到osip工程目录下，并在ＶＣ６中操作：<br>　　Ｐｒｏｊｅｃｔ－Ｓｅｔｔｉｎｇ－Ｌｉｎｋ中的Ｏｂｊｅｃｔ／Ｌｉｂｒａｒｙ　Ｍｏｄｕｌｅｓ：<br>       kernel32.lib user32.lib … xxx.lib之类的内容最后增加: osipparser2.lib<br>　　保存工程后再次编译，即可成功编译osip2.dll。<br>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－<br>　　至此，我们得到了完整的ｏＳＩＰ开发库，使用时，只需在我们的程序里包含ｏＳＩＰ的头文件，工程的链接参数里增加osipparser2.lib和osip2.lib即可。<br>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－<br>　　下面我们验证一下我们得到的开发库，并大概了解一下ＯＳＩＰ的语法规范。<br>　　在VC里创建win32控制台程序工程，将libosip源码包的SRC目录下的Test目录内的C源程序随便拷一个到工程时，直接编译（工程设置里照前文方法在link选项里增加osip2.lib,osipparser2.lib引用我们之前成功编译得到的静态库文件）就可以运行（带参数运行，参数一般为一个文本文件，同样从Test目录的res目录里拷一个与源文件同名的纯文本文件到工程目录下即可）。<br>　　该目录下的若干文件基本上是测试了Osip的一些基本功能函数，例如URI解析之类，可以大概了解一下oSIP的语法规范和调用方法，同时也能校验一下之前编译的OSIP开发库能否正常使用，成功完成本项工作后，可以进入下一步具体的oSIP的使用学习了。<br>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－<br>　　由于ｏＳＩＰ是比较底层的ＳＩＰ协议栈实现，新手较难上手，而官方的示例大都是一些伪代码，需要有实际的例子程序参考学习，而最好的例子就是同样官方发布的ｏＳＩＰ的扩展开发库exosip２，使用ｅｘｏＳＩＰ可以很方便地快速创建一个完整的ＳＩＰ程序（只针对性地适用于SIP终端开发用，所以我们这里只是用它快速开发一个SIP终端，用来更方便地学习oSIP，要想真正掌握SIP的开发，需要掌握oSIP并熟读RFC文档才行，exoSIP不是我们的最终学习目的），通过成功编译运行一个自己动手开发出的程序，再由浅入深应该是初学都最好的学习方法通过对使用exosip开发库的使用创建自己的ＳＩＰ程序，熟悉后再一个函数一个函数地深入学习exosip提供的接口函数，就可以深入理解osip 了，达到间接学习ｏＳＩＰ的目的，同时也能从eXoSIP中学习到正确使用ｏＳＩＰ的良好的编程风格和语法格式。<br>　　而要成功编译ＥｘｏＳＩＰ，似乎许多人被难住了，直接在ＸＰ－ｓｐ２上，用ＶＣ６，虽然你使用了ｅＸｏＳＩＰ推荐的winsock2.h，但是会得到一个sockaddr_storage结构不能识别的错误，因为vc6自带的开发库太古董了，需要升级系统的Ｐｌａｔｆｏｒｍ　ＳＤＫ，下载地址如下：<br><a target="_blank" rel="noopener" href="http://www.microsoft.com/msdownl">http://www.microsoft.com/msdownl</a> … PSP2FULLInstall.htm（ＶＣ６的支持已经停止，这是ＶＣ６能使用的最新ＳＤＫ）<br>　　成功安装后编译前需加OSIP_MT宏，以启用线程库，否则在程序中使用eXoSIP库时会出错，而编译时也会得到许多函数未定义的Warning提示，编译得到exosip2.lib供我们使用，当然，在此之前需要成功编译了osip2和osipparser2，而在之后的实际使用时，发现ｏＳＩＰ也需要增加ＯＳＩＰ＿ＭＴ宏，否则ＯＳＩＰ＿ＭＴ调用ｏＳＩＰ的线程库时会出错，所以我们需要重新编译ｏＳＩＰ了：），因为ｅＸｏｓｉｐ是基于ｏＳＩＰ的（同上方式创建静态和动态链接库工程，并需在Ｌｉｎｋ中手工添加ｏＳＩＰ和ｏＳＩＰｐａｒｓｅｒ的lib库）。<br>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－<br>　　创建新工程，可以是任意工程，我们从最简单的Ｗｉｎ３２控制台程序开始，为了成功使用ｏＳＩＰ，我们需要引用相关库，调用相关头文件，经过多次试验，发现需要引用如下的库：<br>         exosip2.lib osip2.lib osipparser2.lib WSock32.Lib IPHlpApi.Lib WS2_32.Lib Dnsapi.lib<br>　　其中，除了我们上面编译得到的三个oSIP库外，其它库都是系统库，其中有一些是新安装的Ｐｌａｔｆｏｒｍ　ＳＤＫ所新提供的。<br>　　至此，我们有了一个简单的开发环境了，可以充分利用网上大量的以ｏＳＩＰ为基础的代码片段和官方说明文档开始具体函数功能的测试和使用了：）<br>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－<br>　　我们先进行一个简单的纯ＳＩＰ信令（不带语音连接建立）的ＵＡＣ的ＳＩＰ终端的程序开发的试验（即一个只能作为主叫不能作为被叫的的ＳＩＰ软电话模型），我们创建一个ＭＦＣ应用程序，对话框模式，照上面的说明，设置工程包含我们上面得到的ｏＳＩＰ的相关开发库及ＳＤＫ的一些开发库，并且由于默认ＬＩＢＣ的冲突，需要排除MSVCRT[D]开发库（其中Ｄ代表Ｄｅｂｕｇ模式下，没有Ｄ表示Ｒｅｌｅａｓｅ模式下），直接使用ｅＸｏｓｉｐ的几个主要函数就可以创建一个基本的ＳＩＰ软电话模型。</p>
<p>　　其主要流程为：<br>　　初始化ｅＸｏｓｉｐ库－启动事件监听线程－向ＳＩＰ　Ｐｒｏｘｙ注册－向某ＳＩＰ终端（电话号码）发起呼叫－建立连接－结束连接</p>
<p>　　初始化代码：<br>        int ret &#x3D; 0;<br>        ret &#x3D; eXosip_init ();<br>       eXosip_set_user_agent(“##YouToo0.1”);<br>        if(0 !&#x3D; ret)<br>        {<br>               AfxMessageBox(“Couldn’t initialize eXosip!\n”);<br>               return false;<br>        }<br>        ret &#x3D; eXosip_listen_addr (IPPROTO_UDP, NULL, 0, AF_INET, 0);<br>        if(0 !&#x3D; ret)<br>        {<br>               eXosip_quit ();<br>               AfxMessageBox(“Couldn’t initialize transport layer!\n”);<br>               return false;<br>        }</p>
<p>　　启动事件监听线程：<br>       AfxBeginThread(sip_uac,(void *)this);</p>
<p>　　向ＳＩＰ　Ｐｒｏｘｙ注册：<br>       eXosip_clear_authentication_info();<br>       eXosip_add_authentication_info(uname, uname, upwd, “md5”, NULL);<br>       real_send_register(30);　　</p>
<p>　　发起呼叫（构建假的ＳＤＰ描述，实际软电话使用它构建ＲＴＰ媒体连接）：<br>        osip_message_t *invite &#x3D; NULL;<br>        int i &#x3D; eXosip_call_build_initial_invite (&amp;invite, dest_call, source_call, NULL, “## YouToo test demo!”);<br>        if (i !&#x3D; 0)<br>        {<br>               AfxMessageBox(“Intial INVITE failed!\n”);<br>        }<br>        char localip[128];<br>        eXosip_guess_localip (AF_INET, localip, 128);<br>        snprintf (tmp, 4096,<br>               “v&#x3D;0\r\n”<br>               “o&#x3D;josua 0 0 IN IP4 %s\r\n”<br>               “s&#x3D;conversation\r\n”<br>               “c&#x3D;IN IP4 %s\r\n”<br>               “t&#x3D;0 0\r\n”<br>               “m&#x3D;audio %s RTP&#x2F;AVP 0 8 101\r\n”<br>               “a&#x3D;rtpmap:0 PCMU&#x2F;8000\r\n”<br>               “a&#x3D;rtpmap:8 PCMA&#x2F;8000\r\n”<br>               “a&#x3D;rtpmap:101 telephone-event&#x2F;8000\r\n”<br>               “a&#x3D;fmtp:101 0-11\r\n”, localip, localip, “9900”);<br>        osip_message_set_body (invite, tmp, strlen(tmp));<br>       osip_message_set_content_type (invite, “application&#x2F;sdp”);<br>        eXosip_lock ();<br>        i &#x3D; eXosip_call_send_initial_invite (invite);<br>        eXosip_unlock ();                               </p>
<p>　　挂断或取消通话：<br>        int ret;<br>        ret &#x3D; eXosip_call_terminate(call_id, dialog_id);<br>        if(0 !&#x3D; ret)<br>        {<br>               AfxMessageBox(“hangup&#x2F;terminate Failed!”);<br>        }</p>
<p>　　可以看到非常简单，再借助于ｏＲＴＰ和Ｍｅｄｉａｓｔｒｅａｍｅｒ开发库，来快速为我们的ＳＩＰ软电话增加ＲＴＰ和与系统语音ＡＰＩ接口交互及语音编码功能，即可以快速开发出一个可用的ＳＩＰ软电话，关于ｏＲＴＰ和Ｍｅｄｉａｓｔｒｅａｍｅｒ的相关介绍不是本文重点，将在有空的时候考虑增加相应使用教程，文章前提到的地方可以下载基本可用的完整ＳＩＰ软电话的ＶＣ源码工程文件供参考使用，完全ＣｏｐｙＬｅｆｔ，欢迎转载，但请在转载时注明作者信息，谢谢！</p>
<ul>
<li>第二阶段：<br>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－<br>　　得到了一个ＳＩＰ软电话模型后，我们可以根据软电话的实际运行表现（结合用Ethereal抓包分析）来进行代码的分析，以达到利用eXoSIP来辅助我们学习ｏＳＩＰ的最终目的（如要快速开发一个可用的ＳＩＰ软电话，请至前面提到的论坛去下载使用ｏＲＴＰ和Ｍｅｄｉａｓｔｒｅａｍｅｒ快速搭建的一个基本完整可用的ＳＩＰ软电话##YouToo 0.1版本的ＶＣ源码工程文件作参考）。</li>
</ul>
<p>　　现在从eXosip的初始化函数开始入手，来分析oSIP的使用，这是第二阶段，第三阶段就是深入学习oSIP的源码了，但大多数情况下应该没有必要了，因为在第二阶段就有部分涉及到第三阶段的工作了，而且ｏＳＩＰ的源码也就大多是一些ＳＩＰ数据的语法解析和状态机的实现，能深入理解了ＳＩＰ协议后，这些只是一种实现方式，没必要完全去接受，而是可以用自己的方式和风格来实现一套，比如，更轻量化更有适用目的性的方式，ｏＳＩＰ则只起参考作用了。</p>
<p>　　eXosip_init()是ｅＸｏｓｉｐ的初始化函数，我们来看看它的内部实现:<br>　　首行是定义的　osip_t *osip，这在oSIP的官方手册里我们看到，所有使用oSIP的程序都要在最开始处声明一个osip_t的指针，并使用osip_init(&amp;osip)来初始化这个指针，销毁这个资源使用osip_release(osip)即可。<br>　　我们可以在代码中看到很多OSIP_TRACE，这是调试输出宏调用了函数osip_trace，可以用ENABLE_TRACE宏来打开调试以方便我们开发调试。<br>　　其它就是很多的eXosip_t的全局变量eXosip的一些初始化操作，包括最上面的memset (&amp;eXosip, 0, sizeof (eXosip))完全清空和下面的类似eXosip.user_agent &#x3D; osip_strdup (“eXosip&#x2F;“ EXOSIP_VERSION)的exosip变量的一些初始值设置，其中有一个eXosip.j_stop_ua &#x3D; 0应该是一个状态机开关，后面可以看到很多代码检测这个变量来决定是否继续流程处理，默认置成了0表示现在exosip的处理流程是就绪的，即ua是not stop的。<br>　　<br>　　osip_set_application_context (osip, &amp;eXosip)是比较有意思的，它让下面的eXosip_set_callbacks (osip)给osip设置大量的回调函数时，能让osip能访问到eXosip这个全局变量中设置的大量程序运行时交互的信息，相当于我们在ＶＣ下开启一个线程时，给线程传入的一个ｖｏｉｄ指针指向我们的ＭＦＣ应用程序的当前dialog对象实例，可以用void *osip_get_application_context (osip_t * osip)这个函数来取出指针来使用，不过好象exosip中并没有用到它，可能是留给个人自已扩展的吧:)<br>　　<br>　　还能看到初始化代码前面有一段ＷＩＮ３２平台下的ＳＯＣＫ的初始化代码，可以知道eXosip是用的原生的winsock api函数，也就是我们可能以前学过的用VC和WINAPI写sock程序时(不是ＭＦＣ)，用到的那段ＳＯＣＫ初始代码，还有一段有意思的代码，就是jpipe()函数，它们返回的是一个管道，一个有２个整型数值的数组（一个进一个出），查看其代码发现，非WIN32平台是直接使用的pipe系统函数，而ＷＩＮ３２下则是用一对ＴＣＰ的本地ＳＯＣＫ连接来模拟的管道，一个ＳＯＣＫ写一个ＳＯＣＫ读，这段代码是比较有参考价值的：）<br>j &#x3D; 50;<br>while (aport++ &amp;&amp; j– &gt; 0)<br>{<br>　　raddr.sin_port &#x3D; htons ((short) aport);<br>　　if (bind (s, (struct sockaddr *) &amp;raddr, sizeof (raddr)) &lt; 0)<br>　　{<br>　　　　OSIP_TRACE (osip_trace (__FILE__, __LINE__, OSIP_WARNING, NULL,<br>　　　　“Failed to bind one local socket %i!\n”, aport));<br>　　} else<br>　　break;<br>}<br>含义即，依次检测５０个端口，从static int aport &#x3D; 10500;即10500~10550端口找出一个可用的本地端口来绑定listen模拟pipe的一对sock。<br>　　eXosip_set_callbacks (osip)没有什么好看的，无非是和ｏＳＩＰ官方文档介绍的一样，设置一大堆的回调函数，关键是回调函数的实现，这也是许多初学者使用ｏＳＩＰ被卡壳的主要原因，不知道ｏＳＩＰ构建的程序是怎样跑起来的，随便选几个回调函数看一下eXosip是怎样实现的，有许多是形如下文的函数：<br>static void<br>cb_sndbye (int type, osip_transaction_t * tr, osip_message_t * sip)<br>{<br>　　OSIP_TRACE (osip_trace<br>　　(__FILE__, __LINE__, OSIP_INFO3, NULL, “cb_sndbye (id&#x3D;%i)\r\n”,<br>　　tr-&gt;transactionid));<br>}<br>　　即，只是打印一下调试，并没有完整实现什么功能，我们学习时，完全可以用相同的方法，定义一大堆回调函数，并不忙想怎么完全实现，先都是只打印一下调试信息，看具体的应用逻辑根据抓包测试分析和看调试看程序走到了哪一步，调用了哪一个回调，来明白具体回调函数要实现什么用途，再来实现代码就方便多了，当然，如果看透了ＲＦＣ文档，应该从字面就能知道各个回调函数的用途了，这是后话，不是谁都能快速完全看懂ＲＦＣ的，所以我们要参考eXosip：）<br>　　<br>　　我们对其中的重要的回调函数进行逐个的分析：<br>　　－－－－－－－－－－－－－－－－－－－－－－－－－－－<br>　　osip_set_cb_send_message (osip, &amp;cb_snd_message)　ＳＩＰ消息发送回调函数<br>　　这个函数可能是最重要的回调函数之一，消息发送，包括请求消息和回应消息，一般情况下，状态机的状态就是由它控制的，发起一个消息初始化一个状态机，回应一个消息对状态机修改，终结消息发送结束状态机……<br>　　看cb_snd_message的函数实现，要以发现，其主要代码是对参数中的要发送的消息osip_message_t * sip进行分析，找出消息要发送的真实char *host,int port的值（这些参数可以省略，但要发送消息肯定需要host和port，所以要从sip中解析），最后根据sip中解析出的传输方式是TCP还是UDP选择最终进行消息发送处理的函数cb_udp_snd_message，cb_tcp_snd_message处理（它们的参数一致，即本函数只是补全一些省略的参数并对消息进行合法性检查）。<br>　　**毕竟eXosip是一个通用的开发库，它考虑了要支持TCP,UDP,TCPs,IPV4,IPV6，WIN32,*nix,WINCE等等多样化的复杂环境，所以，我们可以略过我们暂时不需要的部分，比如，ＩＰＶ６相关的代码实现等。<br>　　<br>　　由于我们大多数情况下ＳＩＰ是用的ＵＤＰ，所以先来看一下cb_udp_snd_message的实现，它从全局变量exosip中获取可用的sock，并尽最大能力解析出host和port（？？难道前面的函数还不够解析彻底？？如最终仍无port信息则默认设置为5060），使用osip_message_to_str (sip, &amp;message, &amp;length)函数将要发送的格式化的ＳＩＰ消息转换成能用ＳＯＣＫ传输的简单数据并发送即完成消息发送，代码中有许多复杂的环境探测和错误控制等等等等，我们可以暂时不用过多关注，可以继续向下，结尾处有一个keeplive相关代码，从代码字面分析，可能是ＳＩＰ的Register消息的自动重发相关代码，可以在后面再细化分析。<br>　　cb_tcp_snd_essage的函数实现要比上文的udp的实现简单很多，主要是环境探测错误控制方面，因为毕竟tcp是稳定连接的，对比一下代码，可以看到主要流程还是将ＳＩＰ消息转换后，发送到从ＳＩＰ消息中解析出的host和port对应的目标。<br>　　<br>　　看完两个函数，可以知道，eXosip需要有两个sock，是一个数组，0是给ＵＤＰ用的，１是给ＴＣＰ用的，要用ＳＯＣＫ当然要初始化，就是下文要介绍的eXosip的网络相关的初始化了，上面的exosip_init可以看成是这个开发库的系统初始化吧：）　<br>　　至些，我们应该知道了ｏＳＩＰ开发的ＳＩＰ应用程序的消息是从哪里发出的吧，对了，就是从这个回调函数里，所谓万事开头难，就象开发ＷＩＮ３２应用程序时，找到了ＷＩＮ３２程序的main函数入口下面的工作就好办了，下面就都是为一些事件消息开发对应的处理函数而已了：）</p>
<p>　　osip_set_kill_transaction_callback　事务终结回调函数<br>　　对应ＩＣＴ，ＩＳＴ，ＮＩＣＴ，ＮＩＳＴ客户&#x2F;服务器注册&#x2F;非注册事务状态机的终结，主要是使用osip_remove_transaction (eXosip.j_osip, tr)将当前tr事务删除，再加上一系列的清理工作，其中，NICT即客户端的非Ｉｎｖｉｔｅ事务的清理比较复杂一些，要处理的内容也比较多，可以根据实际应用的情况进行有必要的清理工作：）</p>
<p>　　cb_transport_error　传输失败处理回调<br>　　对应于上面说到的四种事务状态机，如果它们在处理时失败，则在这时进行统一处理。<br>　　从代码可知，只是在NOTIFY,SUBSCRIBE,OPTION操作失败才进行处理，其它错误可直接忽略。</p>
<p>　　osip_set_message_callback　消息发送处理回调<br>　　根据type不同，表示不同的消息发送状态<br>　　OSIP_XXX_AGAIN 重发相关消息<br>　　OSIP_ICT_INVITE_SENT 发起呼叫<br>　　OSIP_ICT_ACK_SENT　ＡＣＫ回应<br>　　OSIP_NICT_REGISTER_SENT　发起注册<br>　　OSIP_NICT_BYE_SENT　ＢＹＥ发出<br>　　OSIP_NICT_CANCEL_SENT　Ｃａｎｃｅｌ发出<br>　　OSIP_NICT_INFO_SENT，OSIP_NICT_OPTIONS_SENT，OSIP_NICT_SUBSCRIBE_SENT，OSIP_NICT_NOTIFY_SENT，OSIP_NICT_UNKNOWN_REQUEST_SENT<br>　　我们可以看到，eXosip没有对它们作任何处理，我们可以根据自己需要，比如，重发2xx消息前记录一下日志之类的，扩展一下retransmission的处理方式，发起Invite前记录一下通话日志等等。</p>
<p>　　OSIP_ICT_STATUS_1XX_RECEIVED　uac收到1xx消息，一般是表示对端正在处理中，这时，主要是设置一下事务状态机的状态值，并对会话中的osip的一些参数根据返回值进行相应设置，里面有许多条件判断，但我们常用的一般是100,180,183的判断而已，暂时可以忽略里面复杂的判断代码。<br>　　OSIP_ICT_STATUS_2XX_RECEIVED uac收到2xx消息，这里主要跟踪一下Register情况下的2xx，表示注册成功，这时会更新一下exosip的注册字段值，以便让eXosip能自动维护uac的注册，ＢＹＥ的２ｘｘ回应是终结消息，Invite的2xx回应，则主要是初始化一下会话相关的数据，表示已成功建立连接。<br>　　其它４ｘｘ，５ｘｘ，６ｘｘ则分别是对应的处理，根据实现情况进行概要的查看即可。<br>　　report_event (je, sip)是代码中用来进行事件处理的一个函数，跟踪后发现，其最终是使用了我们上文提到的ｊｐｉｐｅ管道，以便在状态机外实时观测状态机内的处理信息。<br>　　<br>　　OSIP_NIST_STATUS_XXX_SENT即对应于上面的uac的处理，这里是uas的对应的消息处理，相比较于uac简单一点。</p>
<p>　　前面简单介绍了一下大量的回调函数及它们的概要处理逻辑，可能会比较混乱，暂时不用管它，只需要记得一个大概的形象，知道一个ＳＩＰ处理程序是通过osip_set_cb_send_message回调函数来实现真实地发送各种ＳＩＰ消息，并且ＳＩＰ的标准事务模型是由ｏＳＩＰ实现好了，我们只需要给不同的事务状态设置不同的回调处理函数来处理事务，具体的状态变化和内部逻辑不用管就可以了。</p>
<p>　　下面来说一下消息处理回调函数用到的ＳＯＣＫ的初始化函数，即我们上面说的除了系统初始化外的网络初始化函数eXosip_listen_addr：<br>　　从上文知道了，系统将初始化两个ＳＯＣＫ，一个ＵＤＰ一个ＴＣＰ，但查看代码发现还有第三个，ＴＣＰｓ的，但好象还不能实用，现在不管它，代码首先是根据传输是ＵＤＰ还是ＴＣＰ来设置对应的数组值，并且如果没有提供ＩＰ地址和端口号，系统会自动取出本机网络接口并创建可用的ＳＯＣＫ（http_port的方式暂不用考虑）。<br>　　ＳＯＣＫ初始化后，如何开始ＳＩＰ事务的呢？看到这个调用eXosip.j_thread &#x3D; (void *) osip_thread_create (20000, _eXosip_thread, NULL)，对的，这里启用了一个线程，即，ｅＸｏｓｉｐ是调用ｏＳＩＰ的线程函数（没用系统提供的线程函数，是为了跨平台）进行事务处理的状态机逻辑是在一个线程中处理的，这样就明白了为什么一直没能看到顺序执行下来的程序启动代码了，接下去看，线程实际处理函数是_eXosip_thread，这里面的代码中，我们看到了上文提到的状态机控制开关变量while (eXosip.j_stop_ua &#x3D;&#x3D; 0)，即，当j_stop_ua设置为1时，osip_thread_exit ()结束事务处理即程序终结，再接下去看，_eXosip_execute是最终的处理函数了，而且它在程序未终结情况下是一直逻辑在执行，注意，要启用ｏＳＩＰ的多线程宏OSIP_MT。<br>　　<br>　　看到_eXosip_execute的代码中有很多时间函数和变量，仔细看，除去一些控制代码，主要处理函数是eXosip_read_message (1, lower_tv.tv_sec, lower_tv.tv_usec)，即取出消息，1表示只取出一条消息，其代码量非常的大，但同样的，其中也许多的控制代码和错误检测代码，我们在查看时可以暂时忽略掉它们。<br>　　eXosip_read_message读取消息时，即没有采用sock的block也没有用非block方式，而是采用了select方式，具体应用可查询fd_set相关文档。<br>　　根据jpipe_read (eXosip.j_socketctl, buf2, 499)，我们可以估计，buf2中应该是保存的我们的控制管道的数据，具体作用至些还没有表现出来，应该是用来反映一些状态机内部的警示之类的信息，实际的ＳＩＰ的处理的状态机的数据是存放在buf中，使用_eXosip_recvfrom获取的，获取后sipevent &#x3D; osip_parse (buf, i)解析，使用osip_find_transaction_and_add_event (eXosip.j_osip, sipevent)来查询事件对应的事务状态机，找到后就如同其注解所说明的，，即我们上文设置的那一大堆回调函数，至此，我们知道了整个ＳＩＰ应用所处理的大概流程了。<br>　　如果没有找到事务状态机呢？直接丢弃吗？不是的，如果这是一个回应消息，但没有事务状态机处理它，那它是一个错误的，要进行清理后才能丢弃，而如果是一个请求，那更不能丢弃了，因为UAS事务状态机要由它来启动创建的(回应消息表示本地发出了请求消息，即ＵＡＣ行为，事务状态机应是由启动ＵＡＣ的代码初始化启动的)，整个逻辑应该是很简单的，但ｅＸｏｓｉｐ的实现代码却非常多，可见其花了非常多的精力在保证会话的稳定性和应付网络复杂情况上，我们可以对其进行大量的精简来构建满足我们需求的代码实现。<br>　　先来看错误的回应消息的处理函数eXosip_process_response_out_of_transaction，可以看到其代码就是一大堆的赋值语句，XXX&#x3D; NULL，即将一大堆的运行时变量清空，再调用osip_event_free清空事件，或者就是一些复杂的情况下，需要通过解析现在的运行时数据，从中分析出“可能”的正在等待回应的对端，并发送相关终结通知消息等等，可以根据实际需要进行简化。<br>　　请求事件的处理eXosip_process_newrequest，首先是对事件进行探测，MSG_IS_INVITE、MSG_IS_ACK、MSG_IS_REQUEST……，对事件进行所属状态机分类，随后使用_eXosip_transaction_init (&amp;transaction,(osip_fsm_type_t) tx_type,eXosip.j_osip, evt-&gt;sip)根据探测结果进行状态机初始化，实际调用的是osip_transaction_init，初始化后即将事件入状态机osip_transaction_add_event (transaction, evt)，由状态机自动处理后调用相应回调函数处理逻辑了。当然，ｅＸｏｓｉｐ为方便快速开发ＳＩＰ终端应用，在下面又添加了许多自动化的处理代码，来和我们在回调函数中设置的处理代码相区分。</p>
<p>　　线程调用的事件处理函数代码最后是<br>if (eXosip.keep_alive &gt; 0)<br>{<br>　　_eXosip_keep_alive ();<br>}<br>　　这段代码印证了上文提到了，keep_alive是用来设置是否自动重新注册，由_eXosip_keep_alive函数来实现自动将eXosip全局变量中保存的注册消息解析后自动根据需要重新向ＳＩＰ服务器发起Ｒｅｇｉｓｔｅｒ注册。<br>　　同样，因为注册消息发起是ＵＡＣ的行为，将它放在这里，可以看出来所有事件消息的事务状态机处理都是在这里，只不过这里只创建ＵＡＳ的事务状态机，ＵＡＣ的事务状态机的创建则要继续到下面找了，从我们的ＹｏｕＴｏｏ软电话代码中可知，发起呼叫和发起注册分别调用了eXosip_call_send_initial_invite，eXosip_register_send_register这两个函数（另外用到的两个build函数则是分别构建这两个send函数要发送的ＳＩＰ消息），查看这两个函数可知，ＵＡＣ的事务处理状态机是在这里进行初始化的。<br>　　eXosip_register_send_register中可以看到是_eXosip_transaction_init (&amp;transaction, NICT, eXosip.j_osip, reg)初始化ＵＡＣ状态机，实际也同ＵＡＳ是调用的osip_transaction_init函数，同样使用osip_transaction_add_event (transaction, sipevent)将事件入状态机，状态机随后将自动处理调用相应回调函数处理逻辑了。<br>　　另有osip_new_outgoing_sipmessage(reg)，表示发送消息，到这里，我们应该可以理解，真实的发送操作，是要到由状态机处理后，调用了消息发送回调函数才真正地将注册消息发送出去的。<br>　　同注册消息发送，它是ＮＩＣＴ状态机，呼叫消息的发送是ＩＣＴ，由eXosip_call_send_initial_invite处理，_eXosip_transaction_init (&amp;transaction, ICT, eXosip.j_osip, invite)初始化了状态机，之前还有一个eXosip_call_init是用来初始化eXosip的一些参数的，暂时不管它，同样osip_new_outgoing_sipmessage (invite)发送呼叫消息，但实际还是要状态机处理后调用消息发送回调函数真实发送呼叫请求函数的，osip_transaction_add_event (transaction, sipevent)则标准地，将事件入状态机，状态机将能处理随后的应用逻辑调用相应的回调函数了。</p>
<p>　　好了，作了这么多的分析，我们了解了ｅＸｏｓｉｐ是怎样调用ｏＳＩＰ来形成被我能方便地再次调用的了，可以看到，为了实现最大限度的跨平台和兼容性，代码中有大量的测试代码，宏定义和错误再处理代码，看起来非常吃力，但了解了其主要的调用框架：<br>　　初始化，回调函数设置，ＵＡＣ和ＵＡＳ事务处理状态机的启动，事件处理流程等，就可以基本明白了ｏＳＩＰ各个函数的主要作用和正确的用法了，下一步，可以参考ｅＸｏｓｉｐ来针对某个应用，去除掉大量暂时用不到的代码，来构建一个简单的ＳＩＰ软电话和ＳＩＰ服务器，来进一步深入ｏＳＩＰ学习应用了。　</p>
<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－<br>[下回预告：完全基于ｏＳＩＰ的软电话实现及ｏＳＩＰ进一步学习]</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2007-01-30</span><i class="fa fa-tag"></i><a class="tag" href="/tags/融合通信/" title="融合通信">融合通信 </a><a class="tag" href="/tags/技术分析/" title="技术分析">技术分析 </a><a class="tag" href="/tags/程序开发/" title="程序开发">程序开发 </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://meineson.github.io/sipphone/,MBSTUDIO,oSIP协议栈(及eXoSIP,Ortp等)使用入门,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/osip/" title="OSIP协议栈使用入门（续一：纯协议栈逻辑分析）">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/index/" title="版权声明">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/baidu.js"> </script></body></html>